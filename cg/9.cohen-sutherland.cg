#include <graphics.h>
#include <iostream>

// SPPU CG Group A:4
// Write C++ program to implement Cohen-Sutherland line clipping algorithm.

using namespace std;

int main() {
    int gd = DETECT, gm;
    int X1, Y1, X2, Y2;

    // Input Clipping Window Coordinates
    cout << "Enter the Clipping window Coordinates:" << endl;
    cin >> X1 >> Y1 >> X2 >> Y2;

    // Input Line Coordinates
    float x1, y1, x2, y2;
    cout << "Enter the Line Coordinates:" << endl;
    cin >> x1 >> y1 >> x2 >> y2;

    // Initialize region codes
    float op[2][4];

    // Compute region codes for point 1
    op[0][3] = (x1 < X1) ? 1 : 0;  // Left
    op[0][2] = (x1 > X2) ? 1 : 0;  // Right
    op[0][0] = (y1 < Y1) ? 1 : 0;  // Top
    op[0][1] = (y1 > Y2) ? 1 : 0;  // Bottom

    // Compute region codes for point 2
    op[1][3] = (x2 < X1) ? 1 : 0;  // Left
    op[1][2] = (x2 > X2) ? 1 : 0;  // Right
    op[1][0] = (y2 < Y1) ? 1 : 0;  // Top
    op[1][1] = (y2 > Y2) ? 1 : 0;  // Bottom

    // Initialize graphics mode
    initgraph(&gd, &gm, NULL);

    // Display "Before Clipping"
    outtextxy(100, 100, "Before Clipping:");
    rectangle(X1, Y1, X2, Y2);
    line(x1, y1, x2, y2);
    delay(3000);

    cleardevice();

    // Calculate slope
    float m = (x2 - x1) != 0 ? (y2 - y1) / (x2 - x1) : 0;

    // Debugging output for region codes
    cout << op[0][0] << op[0][1] << op[0][2] << op[0][3] << endl;
    cout << op[1][0] << op[1][1] << op[1][2] << op[1][3] << endl;

    // Check if line is completely inside or clipping is needed
    if (!(op[0][0] == 0 && op[0][1] == 0 && op[0][2] == 0 && op[0][3] == 0 &&
          op[1][0] == 0 && op[1][1] == 0 && op[1][2] == 0 && op[1][3] == 0)) {

        // Check for trivial rejection
        if (((op[0][0] && op[1][0]) == 0) && ((op[0][1] && op[1][1]) == 0) &&
            ((op[0][2] && op[1][2]) == 0) && ((op[0][3] && op[1][3]) == 0)) {

            // Perform line clipping
            if (op[0][0] == 1) {  // Top
                x1 = x1 + (Y1 - y1) / m;
                y1 = Y1;
            }
            if (op[0][1] == 1) {  // Bottom
                x1 = x1 + (Y2 - y1) / m;
                y1 = Y2;
            }
            if (op[0][2] == 1) {  // Right
                y1 = y1 + m * (X2 - x1);
                x1 = X2;
            }
            if (op[0][3] == 1) {  // Left
                y1 = y1 + m * (X1 - x1);
                x1 = X1;
            }

            if (op[1][3] == 1) {  // Left
                y2 = y2 + m * (X1 - x2);
                x2 = X1;
            }
            if (op[1][2] == 1) {  // Right
                y2 = y2 + m * (X2 - x2);
                x2 = X2;
            }
            if (op[1][0] == 1) {  // Top
                x2 = x2 + (Y1 - y2) / m;
                y2 = Y1;
            }
            if (op[1][1] == 1) {  // Bottom
                x2 = x2 + (Y2 - y2) / m;
                y2 = Y2;
            }
        } else {
            // Line is completely outside
            x1 = x2 = y1 = y2 = 0;
        }
    }

    // Display "After Clipping"
    outtextxy(100, 100, "After Clipping:");
    rectangle(X1, Y1, X2, Y2);
    line(x1, y1, x2, y2);

    getch();
    closegraph();

    return 0;
}
